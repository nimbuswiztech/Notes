# GIt Part 2

### Table: Scenario-Based Git Questions & Answers <a href="#table-scenario-based-git-questions--answers" id="table-scenario-based-git-questions--answers"></a>

<table data-header-hidden><thead><tr><th width="68.21484375"></th><th width="313.546875"></th><th></th></tr></thead><tbody><tr><td>#</td><td><strong>Question/Scenario</strong></td><td><strong>Answer</strong></td></tr><tr><td>1</td><td><strong>You pull a colleague’s branch and a merge conflict occurs. How do you resolve it?</strong></td><td>Identify conflicted files (<code>git status</code>), edit to resolve, <code>git add</code> to stage, then <code>git commit</code> to complete the merge.</td></tr><tr><td>2</td><td><strong>You accidentally pushed a secret file to a public repo. How do you remove it from history?</strong></td><td>Use <code>git filter-branch</code> or BFG Repo-Cleaner to remove the file from all commits. Force-push and notify collaborators.</td></tr><tr><td>3</td><td><strong>How do you keep a long-lived feature branch updated with the main branch?</strong></td><td>Regularly merge or rebase main into your feature branch: <code>git checkout feature</code>, <code>git merge main</code> or <code>git rebase main</code>.</td></tr><tr><td>4</td><td><strong>You want to split a large commit into several smaller commits. How?</strong></td><td>Use interactive rebase: <code>git rebase -i HEAD~n</code>, mark with <code>edit</code>, then <code>git reset HEAD^</code> and recommit in smaller chunks.</td></tr><tr><td>5</td><td><strong>You need to collaborate on a new feature with another developer. How do you set up the workflow?</strong></td><td>Create a shared repo. Both create branches, push regularly, review with pull requests, resolve conflicts, merge on approval.</td></tr><tr><td>6</td><td><strong>You have staged files by mistake. How do you unstage them without deleting changes?</strong></td><td>Use <code>git reset HEAD &#x3C;file></code> (to unstage but keep changes in the working directory).</td></tr><tr><td>7</td><td><strong>How do you squash multiple commits into one before merging to main?</strong></td><td>Use <code>git rebase -i HEAD~n</code>, change all but the oldest <code>pick</code> to <code>squash</code>, write a new commit message, finish rebase.</td></tr><tr><td>8</td><td><strong>You want to find which commit or developer introduced a bug. What’s your approach?</strong></td><td>Use <code>git bisect start</code>, mark good/bad revisions, let Git isolate the offending commit by binary search.</td></tr><tr><td>9</td><td><strong>How do you handle a situation where a teammate pushes to the wrong branch?</strong></td><td>Cherry-pick desired commits to the correct branch (<code>git cherry-pick &#x3C;hash></code>), delete from wrong branch, update history.</td></tr><tr><td>10</td><td><strong>You need to apply a specific commit from one branch to another. How?</strong></td><td>Use <code>git cherry-pick &#x3C;commit-hash></code> to apply that commit to your current branch.</td></tr><tr><td>11</td><td><strong>You want to delete a branch both locally and remotely. How?</strong></td><td>Locally: <code>git branch -d branchname</code>. Remotely: <code>git push origin --delete branchname</code>.</td></tr><tr><td>12</td><td><strong>How do you revert a merge commit if it introduced a bug into the main branch?</strong></td><td>Use <code>git revert -m 1 &#x3C;merge-commit-hash></code>, resolve conflicts, and commit.</td></tr><tr><td>13</td><td><strong>How can you recover a commit that has been deleted or lost?</strong></td><td>Use <code>git reflog</code> to find the commit hash, then restore with <code>git checkout</code> or <code>git cherry-pick</code>.</td></tr><tr><td>14</td><td><strong>You stashed your work but now want to reapply your local changes. How?</strong></td><td>Use <code>git stash apply</code> to reapply without removing from stash, or <code>git stash pop</code> to reapply and remove from stash.</td></tr><tr><td>15</td><td><strong>After merging two branches, you notice code duplication and logic errors. What next?</strong></td><td>Carefully review conflicts, refactor code, test thoroughly, and commit with a message detailing the resolution.</td></tr><tr><td>16</td><td><strong>You mistakenly committed a sensitive file and want to remove it from all history.</strong></td><td>Use <code>git filter-branch</code> or BFG to scrub the file, force-push updates, coordinate with team for downstream clone corrections.</td></tr><tr><td>17</td><td><strong>A teammate’s branch diverged significantly from main. What merging strategy do you use?</strong></td><td>Update their branch by merging or rebasing main, resolve conflicts as a team, test thoroughly before final merge.</td></tr><tr><td>18</td><td><strong>You want to tag a release version. What command do you use?</strong></td><td><code>git tag v1.0.0</code> (lightweight) or <code>git tag -a v1.0.0 -m "Release v1.0.0"</code> (annotated tag), then <code>git push --tags</code>.</td></tr><tr><td>19</td><td><strong>How do you ignore untracked files in Git permanently?</strong></td><td>Add file patterns to <code>.gitignore</code> and ensure it’s committed to the repo.</td></tr><tr><td>20</td><td><strong>How would you set up a Git hook to check for code style before allowing commits?</strong></td><td>Create/edit a <code>pre-commit</code> script in <code>.git/hooks/</code>, make it executable, script desired checks, and abort on failure.</td></tr><tr><td>21</td><td><strong>You made some changes but want to discard them and restore files to the last committed state.</strong></td><td>Use <code>git checkout -- &#x3C;file></code> or <code>git restore &#x3C;file></code> if using newer Git versions.</td></tr><tr><td>22</td><td><strong>How do you remove a file from the repository but keep it locally?</strong></td><td>Use <code>git rm --cached &#x3C;file></code> and commit; file remains on disk but is removed from version control.</td></tr><tr><td>23</td><td><strong>Your teammate accidentally overwrote shared history using force-push. How do you recover lost commits?</strong></td><td>Use <code>git reflog</code> to find the lost commit hashes, create a branch at that point if needed, and coordinate with the team.</td></tr><tr><td>24</td><td><strong>How do you manage large binary files in a Git project?</strong></td><td>Use Git LFS (Large File Storage) to track and store binaries, or keep them in a separate repo or submodule.</td></tr><tr><td>25</td><td><strong>You want to make an atomic commit involving only portions of modified files.</strong></td><td>Use <code>git add -p</code> to interactively stage “hunks” and then <code>git commit</code>.</td></tr><tr><td>26</td><td><strong>You need to view only the commits made by a single author.</strong></td><td>Use <code>git log --author="Author Name"</code> to see only those commits.</td></tr><tr><td>27</td><td><strong>You see a merge conflict marker (&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;) in a file. What do you do?</strong></td><td>Manually edit the file to resolve the conflict, remove the markers, then stage and commit.</td></tr><tr><td>28</td><td><strong>A teammate wants to work on a private branch and keep history clean. What’s the best update strategy?</strong></td><td>Use <code>git rebase</code> to incorporate upstream changes, preserving a linear history for later merging to main.</td></tr><tr><td>29</td><td><strong>You want to remove remote-tracking branches that no longer exist.</strong></td><td>Use <code>git remote prune origin</code> to clean them up.</td></tr><tr><td>30</td><td><strong>You want to see which lines of a file were last changed by which author.</strong></td><td>Use <code>git blame &#x3C;file></code> for a line-by-line annotation of the latest changes and authorship.</td></tr><tr><td>31</td><td><strong>You need to apply the same change to multiple branches. How do you proceed?</strong></td><td>Use <code>git cherry-pick &#x3C;commit-hash></code> on the relevant branches, testing for conflicts in each one.</td></tr><tr><td>32</td><td><strong>How do you revert multiple commits without losing the changes in your working directory?</strong></td><td>Use <code>git reset --soft HEAD~n</code> (keeps changes staged), or <code>git reset --mixed HEAD~n</code> (keeps changes unstaged).</td></tr><tr><td>33</td><td><strong>You want to collaborate with multiple remotes (e.g., GitHub and GitLab). How do you manage this?</strong></td><td>Add each with <code>git remote add &#x3C;name> &#x3C;url></code>, fetch from both, and push as needed to both locations.</td></tr></tbody></table>

\
