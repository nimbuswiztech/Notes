# Docker volumes

Containers in Docker are designed to be stateless and easily disposable. Volumes provide a way to persist data generated and used by containers beyond the lifecycle of a single container. This is essential for databases, file storage, and other applications that require persistent storage.

This article delves into the various ways to create and use Docker volumes, complete with examples to illustrate their practical applications.

Press enter or click to view image in full size

<figure><img src="https://miro.medium.com/v2/resize:fit:1400/1*EjM5SWI8iDeQ7PgwD5BAaw.png" alt="" height="427" width="700"><figcaption></figcaption></figure>

## Introduction to Docker Volumes <a href="#id-1e84" id="id-1e84"></a>

Docker volumes are a persistent storage mechanism designed to store data generated by and used by Docker containers. They provide a way to decouple the data lifecycle from the container lifecycle, ensuring that data remains intact even when containers are deleted or recreated.

## Types of Docker Volumes <a href="#id-05d0" id="id-05d0"></a>

Press enter or click to view image in full size

<figure><img src="https://miro.medium.com/v2/resize:fit:2000/1*ULlY3lf03xmEUqeWh0yp8w.png" alt="" height="328" width="1000"><figcaption></figcaption></figure>

### Named Volumes <a href="#caea" id="caea"></a>

Named volumes are user-defined volumes that can be easily referenced by name and reused across multiple containers. They are stored in Docker’s internal volume store.

```
docker volume create myVolume
docker run -d --name my_container -v myVolume:/data node_container
```

### Anonymous Volumes <a href="#eaec" id="eaec"></a>

Anonymous volumes are created when no name is specified. They are typically used for temporary data that does not need to persist beyond the container’s lifecycle.

```
docker run -d --name my_container -v /data node_container
```

### Bind Mounts <a href="#id-6de4" id="id-6de4"></a>

Bind mounts map a directory or file from the host filesystem to a container. This allows direct access to the host’s filesystem, making it ideal for scenarios where data needs to be shared between the host and the container.

```
docker run -d --name my_container -v /path/on/host:/data node_container
```

### tmpfs Volumes <a href="#id-12e5" id="id-12e5"></a>

tmpfs volumes mount a temporary filesystem in the container’s memory. They are useful for storing non-persistent data that shouldn’t be written to disk, like sensitive information or temporary files.

```
docker run -d --name my_container --tmpfs /data node_container
```

## Creating and Managing Docker Volumes <a href="#id-919d" id="id-919d"></a>

### Creating Volumes <a href="#b44e" id="b44e"></a>

To create a named volume, use the following command:

```
docker volume create myVolume
```

### Inspecting Volumes <a href="#id-51e3" id="id-51e3"></a>

To inspect a volume and view its details

```
docker volume inspect myVolume
```

### Removing Volumes <a href="#id-6466" id="id-6466"></a>

To remove a volume that is no longer needed:

```
docker volume rm myVolume
```

<figure><img src="https://miro.medium.com/v2/resize:fit:1362/1*KuEhPDK2wzrsBT70io0HuQ.png" alt="" height="333" width="681"><figcaption></figcaption></figure>

## Using Docker Volumes <a href="#f72c" id="f72c"></a>

### Mounting Named Volumes <a href="#e614" id="e614"></a>

To mount a named volume to a container:

```
docker run -d -v myVolume:/app/data myImage
```

### Mounting Anonymous Volumes <a href="#id-0039" id="id-0039"></a>

To mount an anonymous volume:

```
docker run -d -v /app/data myImage
```

### Using Bind Mounts <a href="#e13a" id="e13a"></a>

To use a bind mount, specify the host path and the container path:

```
docker run -d -v /host/data:/app/data myImage
```

## Examples <a href="#id-05f5" id="id-05f5"></a>

### 1. Persisting Data with Named Volumes <a href="#b650" id="b650"></a>

Create a named volume and use it in a container

```
docker volume create mydata
docker run -d -v mydata:/app/data myImage
```

Any data written to `/app/data` inside the container will persist even if the container is deleted.

### 2: Sharing Data Between Containers <a href="#id-28fc" id="id-28fc"></a>

Use a named volume to share data between multiple containers:sh

```
docker volume create shared_data
docker run -d -v shared_data:/app/data container1
docker run -d -v shared_data:/app/data container2
```

Press enter or click to view image in full size

<figure><img src="https://miro.medium.com/v2/resize:fit:1400/1*NiIkBEVrsQH1AwU8r5mGDA.png" alt="" height="315" width="700"><figcaption></figcaption></figure>

Both containers can read and write to `/app/data`, facilitating data sharing.

## Using Bind Mounts for Development <a href="#id-288e" id="id-288e"></a>

Use bind mounts to map a host directory to a container, allowing for real-time code changes:

```
docker run -d -v $(pwd):/app myImage
```

Changes made to files in the host directory will be immediately reflected in the container.

## Example with a simple Node.js application <a href="#id-7c99" id="id-7c99"></a>

### Step 1: Create a Node.js Application <a href="#id-2af0" id="id-2af0"></a>

First, we create a simple Node.js application that writes data to a file:

Press enter or click to view image in full size

<figure><img src="https://miro.medium.com/v2/resize:fit:1400/1*XUV1BIo-lwzaXkHvjknzOA.png" alt="" height="158" width="700"><figcaption></figcaption></figure>

### Step 2: Create a Dockerfile <a href="#id-93d7" id="id-93d7"></a>

Next, we create a Dockerfile for our Node.js application:

```
FROM node:14

WORKDIR /app

COPY . .

CMD ["node", "app.js"]
```

### Step 3: Now build the docker image <a href="#id-7e54" id="id-7e54"></a>

Press enter or click to view image in full size

<figure><img src="https://miro.medium.com/v2/resize:fit:1400/1*b84QG2fYE76iJBC9T8MDGQ.png" alt="" height="110" width="700"><figcaption></figcaption></figure>

### Step 4: Spin up the container <a href="#bea5" id="bea5"></a>

Press enter or click to view image in full size

<figure><img src="https://miro.medium.com/v2/resize:fit:1400/1*kBVIoSmT14RLBi6FOD4x4Q.png" alt="" height="138" width="700"><figcaption></figcaption></figure>

> **-v myVolume:/app/data**: This option mounts a volume inside the container.

* `myVolume`: This is the name of the volume on the host machine.
* `:/app/data`: This specifies the mount point inside the container. In this case, it mounts the `myVolume` volume from the host into the `/app/data` directory inside the container.

### Step 5: Check the content of the data.txt file <a href="#f873" id="f873"></a>

Press enter or click to view image in full size

<figure><img src="https://miro.medium.com/v2/resize:fit:1400/1*Qnzn-1ct9Nm_lgT3igBXbQ.png" alt="" height="89" width="700"><figcaption></figcaption></figure>

> Click on the Volumes option in Docker Desktop Application to view a list of all volumes managed by Docker on your system.

Press enter or click to view image in full size

<figure><img src="https://miro.medium.com/v2/resize:fit:1400/1*kPIIPlyISZ2w03BoQaPV3Q.png" alt="" height="197" width="700"><figcaption></figcaption></figure>

## Best Practices for Using Docker Volumes <a href="#id-6991" id="id-6991"></a>

* Use named volumes for data that needs to persist beyond the container’s lifecycle.
* Use bind mounts for development purposes or when you need direct access to host files.
* Regularly inspect and clean up unused volumes to free up space.
* Ensure proper access permissions when using bind mounts to avoid security risks.

## Conclusion <a href="#a4d2" id="a4d2"></a>

Docker volumes are a powerful feature that enhances the flexibility and efficiency of containerized applications. By understanding the different types of volumes and how to manage them, you can effectively use Docker to persist, share, and manage data within your containers.

\
